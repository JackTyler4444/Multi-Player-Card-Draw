contract encryptionTester{
    address public encryptedOutput;
    
    function encrpt(bytes32 data, uint8 v, bytes32 r, bytes32 s) {
        encryptedOutput = ecrecover(data,  v,  r,  s);
        //recover public key from elliptic curve signature - arguments are (data, v, r, s)
    }   
    function () { throw; }
}

//The idea of ecrecover is that it is possible to compute the public key 
//corresponding to the private key that was used to create an ECDSA signature 
//given two additional bits which are usually supplied with the signature. 

//The signature itself is the two (encoding of the) elliptic curve points r 
//and s and v is the two additional bits needed to recover the public key.

//This also explains why the return type is address: It returns the address 
//corresponding to the recovered public key (i.e. its sha3/keccak hash). 

//This means to actually verify the signature, you check whether the returned 
//address is equal to the one whose corresponding private key should have 
//signed the hash. 
//https://forum.ethereum.org/discussion/2166/signature-generation-and-verification-in-solidity

//You can generate the signature using e.g. the pybitcointools. 
//The functions decode_sig and ecdsa_raw_sign should be useful. 

//https://pypi.python.org/pypi/pybitcointools/
// thelonious/monkcrypto/crypto.go: https://github.com/eris-ltd/thelonious/blob/master/monkcrypto/crypto.go
//How do I verify a Bitcoin-signed message in an Ethereum contract? : https://www.reddit.com/r/ethereum/comments/3gmbkx/how_do_i_verify_a_bitcoinsigned_message_in_an/
//Verify signature in ethereum contract : https://github.com/bertani/poolicy/commit/49987b60968104586a4f481ed621d18010fd58be

//http://www.righto.com/2014/02/bitcoins-hard-way-using-raw-bitcoin.html
//https://www.realitykeys.com/developers/resources

https://github.com/ethereum/pyethereum/blob/c347089c6aeaceea339f5d5a2d1bfa65edb438af/tests/test_contracts.py#L1189-L1210

ecrecover_code = """
def test_ecrecover(h, v, r, s):
    return(ecrecover(h, v, r, s))
"""


def test_ecrecover():
    s = tester.state()
    c = s.abi_contract(ecrecover_code)

    priv = utils.sha3('some big long brainwallet password').encode('hex')
    pub = bitcoin.privtopub(priv)

    msghash = utils.sha3('the quick brown fox jumps over the lazy dog').encode('hex')
    V, R, S = bitcoin.ecdsa_raw_sign(msghash, priv)
    assert bitcoin.ecdsa_raw_verify(msghash, (V, R, S), pub)

    addr = utils.big_endian_to_int(utils.sha3(bitcoin.encode_pubkey(pub, 'bin')[1:])[12:])
    assert int(utils.privtoaddr(priv), 16) == addr

    result = c.test_ecrecover(utils.big_endian_to_int(msghash.decode('hex')), V, R, S)
    assert result == addr



